### 12.4.1 竞态条件的一个例子

没有使用同步的一个例子【这个程序永远不会结束】

### 12.4.2 竞态条件详解

### 12.4.3 锁对象

有两种机制可防止并发访问一个代码块。

Java语言为此提供了一个synchronized关键字，
另外Java5引入了ReentrantLock类。

### 12.4.4 条件对象

可以使用一个条件对象(condition object)来管理那些已经获得了一个锁却不能有效工作的线程

### 12.4.5 synchronized 关键字

如果一个方法声明时有synchronized关键字，那么对象的锁将保护整个方法。即要调用这个方法，线程必须获取内部对象锁

### 12.4.6 同步块

每个Java对象都有一个锁。线程可以通过调用同步方法获得这个锁。 还有另一种机制可以获得这个锁：即进入一个同步块（synchronized block)。

### 12.4.7 监视器概念

希望不要求程序员考虑显式锁就可以保证多线程的安全性。

monitor 监视器 属性：
- 监视器是只包含私有字段的类
- 监视器类的每个对象有一个关联的锁。
- 所有方法由这个锁锁定
- 锁可以有任意多个关联的条件


### 12.4.8 volatile 字段

volatile关键字为实例字段的同步访问提供了一种免锁机制。
如果声明一个字段为  volatile,那么编译器和虚拟机就会考虑到该字段可能被另一个线程并发更新。

### 12.4.9 final 变量

还有一种情况可以安全地访问一个共享字段，即这个字段声明为final时。


### 12.4.10 原子性

java.util.concurrent.atomic包中有很多类使用了很高效的机器级指令来保证其他操作的原 子性（而没有使用锁）。

### 12.4.11 死锁

锁和条件不能解决多线程中可能出现的所有问题。【比如死锁问题】

遗憾的是，Jva程序设计语言中没有提供任何特性可以避免或打破这些死锁。你必须仔 细设计程序，确保不会出现死锁。


### 12.4.12 为什么废弃 stop 和 suspend 方法

首先来看看 stop 方法，该方法会终止所有未完成的方法，包括 run 方法。

一个线程终止 时，它会立即释放被它锁定的所有对象的锁。这会导致对象处于不一致的状态。

与stop不同，suspend不会破坏对象。但是，如果用suspend挂起一个持有锁的线程，那么，在这个线程恢复运行之前这个锁是不可用的。

### 12.4.13 按需初始化

虚拟机会在第一次使用类时执行一个静态初始化器，而且只执行一次。

虚拟机利用一个锁来确保这一点， 所以你不需要自己编程实现。

### 12.4.14 线程局部变量

ThreadLocal辅助类为各个线程提供各自的实例。

